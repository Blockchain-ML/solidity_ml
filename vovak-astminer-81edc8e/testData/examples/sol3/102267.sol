 

pragma solidity ^0.5.16;

contract ComptrollerInterface {
     
    bool public constant isComptroller = true;

     

    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
    function exitMarket(address cToken) external returns (uint);

     

    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint);
    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) external;

    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint);
    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external;

    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint);
    function borrowVerify(address cToken, address borrower, uint borrowAmount) external;

    function repayBorrowAllowed(
        address cToken,
        address payer,
        address borrower,
        uint repayAmount) external returns (uint);
    function repayBorrowVerify(
        address cToken,
        address payer,
        address borrower,
        uint repayAmount,
        uint borrowerIndex) external;

    function liquidateBorrowAllowed(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint repayAmount) external returns (uint);
    function liquidateBorrowVerify(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint repayAmount,
        uint seizeTokens) external;

    function seizeAllowed(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external returns (uint);
    function seizeVerify(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external;

    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint);
    function transferVerify(address cToken, address src, address dst, uint transferTokens) external;

     

    function liquidateCalculateSeizeTokens(
        address cTokenBorrowed,
        address cTokenCollateral,
        uint repayAmount) external view returns (uint, uint);
}

 

pragma solidity ^0.5.16;

 
contract InterestRateModel {
     
    bool public constant isInterestRateModel = true;

     
    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);

     
    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);

}

 

pragma solidity ^0.5.16;



contract CTokenStorage {
     
    bool internal _notEntered;

     
    string public name;

     
    string public symbol;

     
    uint8 public decimals;

     

    uint internal constant borrowRateMaxMantissa = 0.0005e16;

     
    uint internal constant reserveFactorMaxMantissa = 1e18;

     
    address payable public admin;

     
    address payable public pendingAdmin;

     
    ComptrollerInterface public comptroller;

     
    InterestRateModel public interestRateModel;

     
    uint internal initialExchangeRateMantissa;

     
    uint public reserveFactorMantissa;

     
    uint public accrualBlockNumber;

     
    uint public borrowIndex;

     
    uint public totalBorrows;

     
    uint public totalReserves;

     
    uint public totalSupply;

     
    mapping (address => uint) internal accountTokens;

     
    mapping (address => mapping (address => uint)) internal transferAllowances;

     
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

     
    mapping(address => BorrowSnapshot) internal accountBorrows;
}

contract CTokenInterface is CTokenStorage {
     
    bool public constant isCToken = true;


     

     
    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);

     
    event Mint(address minter, uint mintAmount, uint mintTokens);

     
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

     
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

     
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

     
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


     

     
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

     
    event NewAdmin(address oldAdmin, address newAdmin);

     
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

     
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

     
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

     
    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);

     
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);

     
    event Transfer(address indexed from, address indexed to, uint amount);

     
    event Approval(address indexed owner, address indexed spender, uint amount);

     
    event Failure(uint error, uint info, uint detail);


     

    function transfer(address dst, uint amount) external returns (bool);
    function transferFrom(address src, address dst, uint amount) external returns (bool);
    function approve(address spender, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function balanceOfUnderlying(address owner) external returns (uint);
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);
    function borrowRatePerBlock() external view returns (uint);
    function supplyRatePerBlock() external view returns (uint);
    function totalBorrowsCurrent() external returns (uint);
    function borrowBalanceCurrent(address account) external returns (uint);
    function borrowBalanceStored(address account) public view returns (uint);
    function exchangeRateCurrent() public returns (uint);
    function exchangeRateStored() public view returns (uint);
    function getCash() external view returns (uint);
    function accrueInterest() public returns (uint);
    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);


     

    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);
    function _acceptAdmin() external returns (uint);
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);
    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);
    function _reduceReserves(uint reduceAmount) external returns (uint);
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);
}

contract CErc20Storage {
     
    address public underlying;
}

contract CErc20Interface is CErc20Storage {

     

    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);
    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);


     

    function _addReserves(uint addAmount) external returns (uint);
}

contract CDelegationStorage {
     
    address public implementation;
}

contract CDelegatorInterface is CDelegationStorage {
     
    event NewImplementation(address oldImplementation, address newImplementation);

     
    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;
}

contract CDelegateInterface is CDelegationStorage {
     
    function _becomeImplementation(bytes memory data) public;

     
    function _resignImplementation() public;
}

 

pragma solidity ^0.5.16;

 
 

 
library SafeMath {
     
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

     
    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, errorMessage);

        return c;
    }

     
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction underflow");
    }

     
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

     
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
         
         
         
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

     
    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
         
         
         
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, errorMessage);

        return c;
    }

     
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

     
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
         
        require(b > 0, errorMessage);
        uint256 c = a / b;
         

        return c;
    }

     
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

     
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

 

pragma solidity ^0.5.16;



 
 
contract Context {
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this;  
        return msg.data;
    }
}

 
 
contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

     
    constructor() internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

     
    function owner() public view returns (address) {
        return _owner;
    }

     
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

     
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

     
    function transferOwnership(address newOwner) public onlyOwner {
        require(
            newOwner != address(0),
            "Ownable: new owner is the zero address"
        );
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

 
interface AggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

     
     
     
    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

contract PriceOracle {
     
    bool public constant isPriceOracle = true;

     
    function getUnderlyingPrice(CTokenInterface cToken)
        external
        view
        returns (uint256);
}

contract ChainlinkPriceOracleProxy is Ownable, PriceOracle {
    using SafeMath for uint256;

     
    bool public constant isPriceOracle = true;

    address public ethUsdChainlinkAggregatorAddress;

    struct TokenConfig {
        address chainlinkAggregatorAddress;
        uint256 chainlinkPriceBase;  
        uint256 underlyingTokenDecimals;
    }

    mapping(address => TokenConfig) public tokenConfig;

    constructor(address ethUsdChainlinkAggregatorAddress_) public {
        ethUsdChainlinkAggregatorAddress = ethUsdChainlinkAggregatorAddress_;
    }

     
    function getUnderlyingPrice(CTokenInterface cToken)
        public
        view
        returns (uint256)
    {
        TokenConfig memory config = tokenConfig[address(cToken)];

        (, int256 chainlinkPrice, , , ) = AggregatorV3Interface(
            config
                .chainlinkAggregatorAddress
        )
            .latestRoundData();

        require(chainlinkPrice > 0, "Chainlink price feed invalid");

        uint256 underlyingPrice;

        if (config.chainlinkPriceBase == 1) {
            underlyingPrice = uint256(chainlinkPrice).mul(1e28).div(
                10**config.underlyingTokenDecimals
            );
        } else if (config.chainlinkPriceBase == 2) {
            (, int256 ethPriceInUsd, , , ) = AggregatorV3Interface(
                ethUsdChainlinkAggregatorAddress
            )
                .latestRoundData();

            require(ethPriceInUsd > 0, "ETH price invalid");

            underlyingPrice = uint256(chainlinkPrice)
                .mul(uint256(ethPriceInUsd))
                .mul(1e10)
                .div(10**config.underlyingTokenDecimals);
        } else {
            revert("Token config invalid");
        }

        require(underlyingPrice > 0, "Underlying price invalid");

        return underlyingPrice;
    }

    function setEthUsdChainlinkAggregatorAddress(address addr)
        external
        onlyOwner
    {
        ethUsdChainlinkAggregatorAddress = addr;
    }

    function setTokenConfigs(
        address[] calldata cTokenAddress,
        address[] calldata chainlinkAggregatorAddress,
        uint256[] calldata chainlinkPriceBase,
        uint256[] calldata underlyingTokenDecimals
    ) external onlyOwner {
        require(
            cTokenAddress.length == chainlinkAggregatorAddress.length &&
                cTokenAddress.length == chainlinkPriceBase.length &&
                cTokenAddress.length == underlyingTokenDecimals.length,
            "Arguments must have same length"
        );

        for (uint256 i = 0; i < cTokenAddress.length; i++) {
            tokenConfig[cTokenAddress[i]] = TokenConfig({
                chainlinkAggregatorAddress: chainlinkAggregatorAddress[i],
                chainlinkPriceBase: chainlinkPriceBase[i],
                underlyingTokenDecimals: underlyingTokenDecimals[i]
            });
            emit TokenConfigUpdated(
                cTokenAddress[i],
                chainlinkAggregatorAddress[i],
                chainlinkPriceBase[i],
                underlyingTokenDecimals[i]
            );
        }
    }

    event TokenConfigUpdated(
        address cTokenAddress,
        address chainlinkAggregatorAddress,
        uint256 chainlinkPriceBase,
        uint256 underlyingTokenDecimals
    );
}